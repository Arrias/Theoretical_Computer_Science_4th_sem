\documentclass[12pt, letterpaper]{article}
\def\blank{\medskip\hrule\medskip}
\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx} 
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage[unicode, pdftex]{hyperref}

\renewcommand\qedsymbol{$\blacksquare$}
\renewcommand{\arraystretch}{2} %
\everymath{\displaystyle}

\newtheorem{theorem}{Теорема}[section]
\newtheorem{prop}{Утверждение}[section]
\newtheorem{defi}{Определение}[section]
\newtheorem{sample}{Пример}[section]
\newtheorem{note}{Замечание}[section]

\renewcommand{\O}{\mathcal{O}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\N}{\mathcal{N}}
\renewcommand{\a}{\alpha}
\renewcommand{\b}{\beta}
\renewcommand{\l}{\lambda}
\newcommand{\ph}{\varphi}
\newcommand{\e}{\varepsilon}
\newcommand{\leqp}{\leq_{p}}

\usepackage[%
    left=0.50in,%
    right=0.50in,%
    top=0.50in,%
    bottom=0.50in,%
    paperheight=11in,%
    paperwidth=8.5in%
]{geometry}%

\begin{document}

\section{Билет 1}
\begin{prop}
Пусть $M$ -- одноленточная МТ, которая распознает язык бинарных палиндромов. Тогда существует константа $C : \exists n_o : \forall n > n_0$ существует вход длины $n$, на котором $M(x)$ делает $\geq Cn^2$ шагов.
\end{prop}

\begin{proof}
В начале очевиден принцип несжимаемости, нельзя инъективно перевести строки из $\{0, 1 \}^n$ в $\{0, 1\}^*$ так, чтобы все образы по длине были меньше чем $n$.\\
Будем доказывать для входов, длина которых кратна 3. По $x \in \{0, 1\}^n$ строим вход $x 0^n x^{rev}$ и скармливаем МТ все такие входы. Возьмем все перегородки после нулей, их всего $n$, существует перегородку, через которую МТ прошла $\leq \frac{T(x)}{n}$ раз. \\
Теперь строим отображение $f : \{0, 1\}^n \rightarrow \{0, 1\}^{*}$, переводим строку $x$ в протокол работы МТ на строке $x 0^n rev(x)$. Для этого выпишем набор состояний, в которые переодила МТ, переходя через "хорошую" перегородку и номер этой перегородки. \\
Утверждается, что такая $f$ -- инъекция, чтобы доказать, предположите обратное и рассмотрите работу на строке $x0^n y^{rev}$.\\
Пусть $|x|=n$, тогда $f(x) \leq \log n + \frac{T(x)}{n} C$, но при этом существует $|y|=n$, такой что $f(y) \geq n$. Получаем, что 
$$n \leq log n + \frac{T(x)}{n} C $$
$T(x) = \omega(n^2) $ на таких входах. \\
Для некратных 3 входов делаем также, но по-середине пишем вместо $n$ нулей, на один ноль больше или меньше -- это не влияет на оценки.
\end{proof}

\section{Билет 2}
\begin{defi}
$k$ -- ленточная машина Тьюринга. (Добавляется куча лент и функция перехода теперь действует по всем лентам).
\end{defi}

\begin{prop}
Для любой $k$ -- ленточной МТ, которая на входе $x$ работает время $T(x)$, существует 1 ленточная МТ, которая работает $O(T(x)^2)$.
\end{prop}
\begin{proof}
Будем хранить в одном символе МТ символы всех лент (а также спец символы, помеченные головкой). На каждом шаге будем идти вправо и делать все изменения, которые нужны на лентах. 
\end{proof}

\begin{defi}
Универсальная МТ -- эмулирует МТ по описанию.
\end{defi}

\begin{prop}
Для любой $k$-ленточной МТ существует универсальная $k$-ленточная МТ с линейным замедлением.
\end{prop}
\begin{proof}
Понятно как получить квадратичное замедление, нужно положить описание в начало, например, первой ленты. Далее постоянно возвращаться, чтобы узнать, какой шаг сделать. Если же хотим линейного -- давайте возить описание с собой, это будет давать $O(1)$ действий из-за его константного размера, при этом эмуляция будет работать за линейное время.
\end{proof}

\begin{prop}
$k$ ленточную МТ можно эмулировать на 2-ленточной с логарифмическим замедлением.
\end{prop}
\begin{proof}
TODO
\end{proof}


\section{Билет 3}
Основная модель вычислений -- многоленточная МТ. 
\begin{defi}
$f : \mathbb{N} \rightarrow R_{+}$, тогда $L \in DTime[f(n)]$, если 
существует многоленточная МТ, такая что
\begin{enumerate}
\item $\forall x \in L \Rightarrow M(x) = 1$.
\item $\forall x \notin L \Rightarrow M(x) = 0$.
\item $\forall x$ МТ работает $O(f(|x|)$ шагов.
\end{enumerate} 
\end{defi} 

\begin{defi}
$P = \cup_{i>0} DTime[n^i]$.
\end{defi}

\begin{defi}
Про семейство схем, распознающих язык.
\end{defi}

\begin{defi}
$L \in Size[f(n)]$, если есть последовательность схем, распознающих L и для достаточно больших $n$ выполнено $|C_n| \leq f(n)$.
\end{defi}

\begin{defi}
$P/Poly = \cup_{i>0} Size[n^i]$.
\end{defi}

\begin{sample}
Неразрешимый язык может лежат в $P/Poly$. Например $1^{H}=\{1^{n} | n \in H \}$, для некоторого языка тоже является разрешимым и лежит в $P/Poly$, так как на каждую длину мы можем предоставить схему.  
\end{sample}

\begin{prop}
Существует такой алгоритм $A$, который получает на вход $T,n,m$ и 
\begin{enumerate}
\item $A$ работает $poly(n + T + |m|)$ шагов.
\item Если МТ $m$ на всех входах из $\{0,1\}^{*}$ выдает ответ за $\leq T$ шагов, то алгоритм $A$ выдает схему $C$, которая имеет $n$ входов и 1 выход и распознает на входах длины $n$ также как $m$.
\end{enumerate}
\end{prop}
\begin{proof}
Будем возвращать схему размера $T \times T \cdot O(1)$.\\
На уровне $i$ будет $T$ ячеек, в каждой из которых будет вычисляться некоторая информация: сивмол, написанный в этой ячейке, есть ли тут головка в момент $i$, а также, если есть головка, то состояние, в которой МТ сейчас находится. Понятно, что для пересчета этих параметров нужно обратиться к нескольким соседним ячейкам предыдущей строки. Для того, чтобы узнать ответ, посмотрим, принималось ли где-нибудь состояние $q_{yes}$.\\
\end{proof}

\begin{prop}
$P \subseteq P/Poly$.
\end{prop}

Таким образом хотели доказывать, что $P \neq NP$, взять, к примеру, $SAT$ и показать, что он не лежит в $P / Poly$, однако доказывать нижние оценки на схемы пока что не научились.

\section{Билет 4}
\begin{defi}
$L \subseteq \Sigma^{*}$, система доказательств для языка $L$ -- это такой алгоритм $\Pi$, который обладает следующими свойствами:
\begin{enumerate}
\item (Полнота) $\forall x \in L \Rightarrow \exists w : \Pi(x,w)=1$
\item (Корректность) $\forall x \notin L \Rightarrow \forall w \Pi(x,w) \neq 1$ 
(Ну или равно 0).
\item $\Pi$ всегда останавливается  
\end{enumerate}
\end{defi}

\begin{defi}
Система доказательств $\Pi$ называется эффективной, если $\Pi(x,w)$ работает за $\leq poly(|x|+|w|)$ шагов.
\end{defi}

\begin{note}
Системы доказательств существуют для перечислимых языков, как мы знаем из предыдущий главы курса. Также можно доказать, что для всех перечислимых языков существует и эффективная система доказательств ($TCS12$), искуственно увеличивая подсказку.
\end{note}

\begin{defi}
класс $NP$ состоит языков, для которых существует эффективная система доказательств $\Pi$, а также полином $q$, такой что $\forall x \in L \exists w, |w| \leq q(|x|), \Pi(x,w)=1$, то есть, существует полиномиальная подсказка.
\end{defi}

\begin{sample}
Примеры языков из $NP$.
\begin{enumerate}
\item $SAT$ -- множество выполнимых пропозициональных формул. \\
$SAT \in NP$, но не выяснено, $UNSAT \notin/\in NP$.
\item $Hampath$ -- язык графов, в которых есть гамильтонов путь, также лежит в $NP$.
\item $CLIQUE$ -- язык пар (граф, число) такой, что в графе есть клина на числе вершин. Лежит в $NP$.
\item $Composite$ -- язык составных натуральных чисел, лежит в $NP$, а также, известно, что $Primes \in NP$ ($TCS11$) и, более того, человечество умеет показывать $Primes \in P$.  
\end{enumerate}
\end{sample}

\begin{defi}
Недетерминированные МТ. Вместо одной функции перехода теперь две и машина сама выбирает, в какую идти. ($:)$).\\
Говорят, что недетерминированная $M$ принимает слово, если существует последовательность корректных переходов, при которых она придет в состояние $q_{yes}$ на входе этом слове. \\
Время работы НМ -- максимум по всем возможным применениям функции перехода.
\end{defi}

\begin{defi}
$NTime[f(n)]$ -- множество языков, которые принимаются многоленточными НМТ за $O(f(n))$ шагов, где $n$ -- длина входа.
\end{defi}

\begin{defi}[Второе определение $NP$]
$NP = \cup_{c>0} NTime[n^c]$.
\end{defi}

\begin{defi}[МТ с подсказкой].
К обычной МТ добавляется лента подсказки, на которую записывается некоторая строка, к которой может обращаться МТ во время работы. Машина принимает слово, если существует подсказка, для которой она придет в состояние $q_{yes}$. Время работы такой машины -- максимум по всем подсказкам.
\end{defi}

\begin{theorem}
Следующие условия эквивалентны:
\begin{enumerate}
\item $L \in NP$ (на языке систем доказательств)
\item $L$ распознается машиной Тьюринга с подсказкой за полиномиальное время.
\item $L \in \cup_{c>0} Ntime[n^c]$.
\end{enumerate}
\end{theorem}

\begin{proof}
$(1) \Rightarrow (2)$: построим МТ с подсказкой. Пусть наша МТ при обращениях к подсказке будет теперь обращаться на ленту с подсказкой вместо ленты входа. Тогда понятно, что подсказки аналогичны друг другу.\\
$(2) \Rightarrow (3):$ пусть МТ порождает подсказку, а далее действует детерминированно. Подсказка более чем полиномилаьного размера не нужна, так как наш алгоритм не успеет ее обработать из-за своего времени работы.\\
$(3) \Rightarrow (1):$ подсказка -- какую функцию перехода выбирать на каждом шагу. 
\end{proof}

\section{Билет 5}
\begin{defi}
Язык $A$ сводится по Карпу к языку $B$, если существует полиномиально вычислимая $f$: $\forall x, x \in A \Longleftrightarrow f(x) \in B$. Обозначается $A \leq_{p} B$.
\end{defi}
\begin{prop} Свойства сведения
\begin{enumerate}
\item $A \leqp B$, $B \in P \Rightarrow A \in P$.
\item $A \leqp B, B \leqp C \Rightarrow A \leqp C$. 
\end{enumerate}
\end{prop}

\begin{defi}
Язык $A$ называется $NP$-трудным, если $\forall L \in NP, L \leqp A$. Язык A $NP$-полный, если $A\in NP$ и $A$ -- $NP$-трудный. 
\end{defi}

\begin{defi}
$BH = \{ (M, x, 1^t) | $ $\exists y, M(x,y)$ выдает 1 за $\leq t$ шагов  $\}$. 
\end{defi}

\begin{theorem}
$BH$ -- $NP$-полный.
\end{theorem}
\begin{proof}
Проверим, что $BH \in NP$. Подсказка как раз и будет этот $y$. Запускаем на $t$ шагов и проверяем, приняло или нет. Если тройка лежит в языке, то по определению найдется такая подсказка, что выдаст $yes$. Иначе -- нет.\\
Возьмем $L \in NP$, хотим проверить $L \leqp BH$. У $L$ есть нмт эффективная система доказательств $\Pi$, работающая за $q(|x|+|y|)$, при этом также для лежащих в языке слов есть маленькая подсказка, длины $\leq p(x)$. Давайте сделаем следующее отображение $f(x) = (M, x, 1^{q(|x|+p(|x|))})$. Очевидно, что это корректное сведение.

\end{proof}





\end{document}





